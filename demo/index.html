<html>
    <head>
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

      <script type="module">
      
import * as THREE from 'https://cdn.skypack.dev/pin/three@v0.128.0-SK0zhlI7UZNd0gIQdpJa/mode=imports/optimized/three.js';

let camera, scene, renderer;
let step;
var grounded = true;
let jumped = false;
let playerHitbox;
var collidableMeshList = [];
var antiCollidableMeshList = [];
let geometry, material, mesh, ground, groundgeometry, ground_material;
let sun, sun_geometry, material_sun, amb_light, general_light;
let npc;
var lookaters = [];
let building, building_geometry, building_material;
let door, door2, door_material;
var x = 0.0;
var previousPoint = new THREE.Vector3();
var actions = {};
var interactive = [];
//Textures
const loader = new THREE.TextureLoader();
const texture_empty = loader.load("https://pobulus.github.io/demo/resources/empty.png");
  texture_empty.magFilter = THREE.NearestFilter;
const texture_tiles = loader.load("https://pobulus.github.io/demo/resources/tiles.png");
  texture_tiles.magFilter = THREE.NearestFilter;
  texture_tiles.wrapS = THREE.RepeatWrapping;
  texture_tiles.wrapT = THREE.RepeatWrapping;
  texture_tiles.repeat.set( 10,10 );
const texture_vending_machine_front = loader.load("https://pobulus.github.io/demo/resources/vending_machine_front.png");
const texture_vending_machine_back = loader.load("https://pobulus.github.io/demo/resources/vending_machine_back.png");
const texture_vending_machine_top = loader.load("https://pobulus.github.io/demo/resources/vending_machine_top.png");
const texture_vending_machine_bottom = loader.load("https://pobulus.github.io/demo/resources/vending_machine_bottom.png");
const texture_vending_machine_left = loader.load("https://pobulus.github.io/demo/resources/vending_machine_left.png");
const texture_vending_machine_right = loader.load("https://pobulus.github.io/demo/resources/vending_machine_right.png");
  texture_vending_machine_front.magFilter = THREE.NearestFilter;
  texture_vending_machine_back.magFilter = THREE.NearestFilter;
  texture_vending_machine_top.magFilter = THREE.NearestFilter;
  texture_vending_machine_bottom.magFilter = THREE.NearestFilter;
  texture_vending_machine_left.magFilter = THREE.NearestFilter;
  texture_vending_machine_right.magFilter = THREE.NearestFilter;

const texture_table_top = loader.load("https://pobulus.github.io/demo/resources/table_top.png");
const texture_table_side = loader.load("https://pobulus.github.io/demo/resources/table_side.png");
  texture_table_top.magFilter = THREE.NearestFilter;
  texture_table_side.magFilter = THREE.NearestFilter;
const texture_classroom_1_top = loader.load("https://pobulus.github.io/demo/resources/classroom_1_top.png");
const texture_classroom_1_front = loader.load("https://pobulus.github.io/demo/resources/classroom_1_front.png");
const texture_classroom_1_out_front = loader.load("https://pobulus.github.io/demo/resources/classroom_1_out_front.png");
  texture_classroom_1_top.magFilter = THREE.NearestFilter;
  texture_classroom_1_front.magFilter = THREE.NearestFilter;
  texture_classroom_1_out_front.magFilter = THREE.NearestFilter;
const texture_npc_1_front = loader.load("https://pobulus.github.io/demo/resources/npc_1_front.png");
const texture_npc_2_front = loader.load("https://pobulus.github.io/demo/resources/npc_2_front.png");
  texture_npc_1_front.magFilter = THREE.NearestFilter;
  texture_npc_2_front.magFilter = THREE.NearestFilter;
const texture_door = loader.load("https://pobulus.github.io/demo/resources/door.png")
const texture_door_double = loader.load("https://pobulus.github.io/demo/resources/door_double.png")
  texture_door.magFilter = THREE.NearestFilter;
  texture_door_double.magFilter = THREE.NearestFilter;
//Materials
const material_player = new THREE.MeshBasicMaterial({wireframe:false});
// var hitboxGeometry = new THREE.CylinderGeometry(0.4, 0.15, 1.8, 16,16);
var hitboxGeometry = new THREE.SphereGeometry(0.6, 16, 16);
const material_table_top = new THREE.MeshToonMaterial({map: texture_table_top, transparent: true, alphaTest: 0.5, side: THREE.DoubleSide, });
const material_table_side = new THREE.MeshToonMaterial({map: texture_table_side, transparent: true, alphaTest: 0.5, side: THREE.DoubleSide});

const material_classroom_1_top = new THREE.MeshToonMaterial({map: texture_classroom_1_top, transparent: true, side: THREE.DoubleSide, });
const material_classroom_1_front = new THREE.MeshToonMaterial({map: texture_classroom_1_front, transparent: true, side: THREE.DoubleSide});
const material_classroom_1_out_front = new THREE.MeshToonMaterial({map: texture_classroom_1_out_front, transparent: true});

const material_tiles = new THREE.MeshToonMaterial({map: texture_tiles, side: THREE.DoubleSide});

const material_empty = new THREE.MeshToonMaterial({map: texture_empty, transparent: true, alphaTest: 0.5, side: THREE.BackSide});
const material_npc_1_front = new THREE.MeshToonMaterial({map: texture_npc_1_front, transparent: true, alphaTest: 0.5, side: THREE.DoubleSide});
const material_npc_2_front = new THREE.MeshToonMaterial({map: texture_npc_2_front, transparent: true, alphaTest: 0.5, side: THREE.DoubleSide});
const material_door = new THREE.MeshToonMaterial({map: texture_door, side: THREE.DoubleSide});
const material_door_double = new THREE.MeshToonMaterial({map: texture_door_double, side: THREE.DoubleSide});
 
const npc_materials = [
  material_npc_1_front,
  material_npc_2_front
];
//Box Textures
const texture_classroom_1 = [
  material_classroom_1_front, material_classroom_1_front,
  material_classroom_1_top, material_tiles,
  material_classroom_1_front, material_classroom_1_front
];
const texture_classroom_1_out = [
  material_classroom_1_out_front, material_classroom_1_out_front,
  material_classroom_1_top, material_tiles,
  material_classroom_1_out_front, material_classroom_1_out_front
];
const texture_table = [
  material_table_side, material_table_side,
  material_table_top, material_empty,
  material_table_side, material_table_side
];

const texture_vending_machine = [
  new THREE.MeshToonMaterial({map: texture_vending_machine_left, }),  
  new THREE.MeshToonMaterial({map: texture_vending_machine_right, }),
  new THREE.MeshToonMaterial({map: texture_vending_machine_top,}),  
  new THREE.MeshToonMaterial({map: texture_vending_machine_bottom, }), 
  new THREE.MeshToonMaterial({map: texture_vending_machine_front, }),  
  new THREE.MeshToonMaterial({map: texture_vending_machine_back,}),
   

  
];



let building_outside;
function init() {
  //Hide touch controls
  $("#cameraTouchBox").hide();$("#movementTouchBox").hide();$("#jumpTouchBox").hide();$("#console").hide();
  $("#textbox").hide();$("#interactTouchBox").hide();
  camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 100 );
  camera.position.y = 0.7;
  camera.rotation.x = 0;
  camera.rotation.y = 0;
  collidableMeshList = [];
  actions = {};
 interactive = [];
  scene = new THREE.Scene();
  building_geometry = new THREE.BoxGeometry(10, 3, 10,);

  building = new THREE.Mesh(building_geometry, texture_classroom_1);
  scene.add(building);
  building.scale.x = -1;
  building.translateY(1.45);
  building_outside = new THREE.Mesh(building_geometry, texture_classroom_1_out);
  building_outside.scale.x = 1.001;
  building_outside.scale.z = 1.001;
  building_outside.scale.y = 1.001;
  building.add(building_outside);
  collidableMeshList.push(building);
  ground_material = new THREE.MeshBasicMaterial({color: 0x22aa33, side: THREE.DoubleSide});
  groundgeometry = new THREE.CircleGeometry(20, 100);

  ground = new THREE.Mesh(groundgeometry, ground_material);
  ground.position.y=-0.1;
  ground.rotation.x=-Math.PI/2;
  ground.receiveShadow = true;
  ground.castShadow = true;
  scene.add( ground );
  collidableMeshList.push(ground);
  playerHitbox = new THREE.Mesh(hitboxGeometry, material_player);
  scene.add(playerHitbox);
  sun_geometry = new THREE.CircleGeometry(2, 64);
  material_sun = new THREE.MeshBasicMaterial({color: new THREE.Color(0.8, 0.8, 0)});
 
  sun = new THREE.Mesh(sun_geometry, material_sun);
  console.log(sun.material.color);
  scene.background = new THREE.Color(0.3, 0.7, 0.9)
  door = new THREE.Mesh(new THREE.BoxGeometry(2, 1.55, 0.02), material_door_double);
  door.position.y = 0.7;
  door.position.z = 5;
  scene.add(door);
  antiCollidableMeshList.push(door);
  amb_light = new THREE.AmbientLight( 0x000000, 0.25 ); // soft white light
  general_light = new THREE.AmbientLight( 0xffffff, 0.5 ); // soft white light
  scene.fog = new THREE.Fog(0x000000, 10, 100);
  // scene.add(fog);
  scene.add( amb_light ); 
  scene.add(general_light);
  scene.add(sun);

  makeRandomBoxes(1,1);
  makeATable(0.7);
  lookaters = [];
  for (var cnt = 0; cnt<25; cnt++){
  makeNPC(Math.round(Math.random()), (9.8*Math.random()-4.9), (9.8*Math.random()-4.9));
  }
  
  

  
  renderer = new THREE.WebGLRenderer( { antialias: true } );
  renderer.setSize( window.innerWidth, window.innerHeight );
  renderer.setAnimationLoop( animation );
  document.body.replaceChild( renderer.domElement, document.getElementsByTagName("canvas")[0])
  var canvas = document.querySelector('canvas');
  console.log("INITIALIZED");
  canvas.requestPointerLock = canvas.requestPointerLock ||canvas.mozRequestPointerLock;
  document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;

  canvas.onclick = function() {
    if(touchscreen==false){
    canvas.requestPointerLock();
  }
}
}
var elem = document.documentElement;
let fullscr = false;



function openFullscreen() {
          fullscr = true;
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) { /* Safari */
            elem.webkitRequestFullscreen();
        } else if (elem.msRequestFullscreen) { /* IE11 */
            elem.msRequestFullscreen();
        }
        sleep(500);//give it time to resize
        if (
  document.fullscreenElement || /* Standard syntax */
  document.webkitFullscreenElement || /* Safari and Opera syntax */
  document.msFullscreenElement /* IE11 syntax */
) {
      // renderer = new THREE.WebGlRenderer( { antialias: true } );
      //   renderer.setSize( window.innerWidth, window.innerHeight );
      // renderer.setSize( window.innerWidth, window.innerHeight );
      // document.body.replaceChild( renderer.domElement, document.getElementsByTagName("canvas")[0] );
      // console.log("fullscreen");
      document.removeEventListener("touchstart", openFullscreen);
      document.removeEventListener("dblclick", openFullscreen);
      console.log("Resizing...")
      init();
      

  }
}
var boxes = [];
var light;
function addLight(x, y, z) {
    const color = 0xFFFFFF;
    const intensity = 1;
    light = new THREE.PointLight(color, intensity);
    light.position.set(x, y, z);
    scene.add(light);
    light.shadow.mapSize.width = 512; // default
light.shadow.mapSize.height = 512; // default
light.shadow.camera.near = 0.5; // default
light.shadow.camera.far = 500; // default
  }

function makeNPC(version, x=0, z=0, y=0.4, n="default"){

  let npc_geometry = new THREE.PlaneGeometry(0.5, 0.9);
  npc = new THREE.Mesh(npc_geometry, npc_materials[version]);
  npc.position.y = y;
  npc.position.x = x;
  npc.position.z = z;
  lookaters.push(npc.id);
  npc.name = n;
  interactive.push(npc);
      actions[npc.id] = function(x) {
        var self = scene.getObjectById(x);
        console.log(self.material.map.image.src);
        stare(self);
        $("#portrait").attr("src", self.material.map.image.src);
        $("#speaker-name").html("<b>Student U≈ö</b>");
        $("#text-area").html("Masz dla mnie jakie≈õ paluszki?");
        $("#textbox").show();
      }
  scene.add(npc);
  // collidableMeshList.push(npc);
  

}
function makeATable(size){
  geometry = new THREE.BoxGeometry( size,  2*size/3,  size);
  mesh = new THREE.Mesh( geometry, texture_table);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  scene.add( mesh );
  mesh.position.y = size/4;
  mesh.position.x = 3;
  collidableMeshList.push(mesh);
      // addLight(0,  0,  0);

}
function makeRandomBoxes(rows, cols){
  for (var dubstep = 0; dubstep<rows; dubstep++){
    for (step = 0; step<cols; step++){
      var size = 0.5;
      
      geometry = new THREE.BoxGeometry( size,  size*2,  size);
      
     
      mesh = new THREE.Mesh( geometry, texture_vending_machine);
      interactive.push(mesh);
      actions[mesh.id] = function(x) {
        var self = scene.getObjectById(x);
        console.log("Success!");
        stare(self);
        $("#portrait").attr("src", "resources/vending_machine_front.png");
        $("#speaker-name").html("<b>Automat z przekƒÖskami</b>");
        $("#text-area").html("Hej! Chcesz paluchy wariacie?");
        $("#textbox").show();
      }
      scene.add( mesh );
      
      collidableMeshList.push(mesh);

      // console.log(mesh.name);
      mesh.position.y = 0.5;
      mesh.position.x = 2*(step-cols/2)+0.5;
      mesh.position.z = 2*(dubstep-rows/2);
      mesh.rotation.y = Math.random()*2*Math.PI;
    }
}
}
function stare(obj){
  obj.lookAt(new THREE.Vector3(camera.position.x, obj.position.y, camera.position.z));
}
function sleep(milliseconds) {
  const date = Date.now();
  let currentDate = null;
  do {
    currentDate = Date.now();
  } while (currentDate - date < milliseconds);
}
        
      
      function closeFullscreen(){
        fullscr = false;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen();
        }
}
var hour = 0;
var dayLength = 100000;
function parseHour(x){
  // console.log(hour);
  return String(Math.floor(hour/6))+":"+String(hour%6)+"0";
}
function animation( time ) {
	renderer.render( scene, camera );
  
  sun.position.x = camera.position.x+30*Math.sin(time/dayLength);
  sun.position.z = camera.position.z+30*Math.sin(time/dayLength);
  sun.position.y = camera.position.y+50*Math.cos(time/dayLength);
  // light.position.set(sun.position.x, sun.position.y, sun.position.z);
  amb_light.color.r = Math.max(1*Math.sin(time/dayLength)**6-0.4, 0);
  
  // console.log(scene.background);
  
  scene.background.r = Math.max(0.8*Math.sin(time/dayLength)**6-0.4, 0);
  sun.material.color = new THREE.Color(((0.4*Math.sin(time/dayLength)**6)+0.6), 0.7, 0.3);
  scene.background.g = 0.6*Math.cos(time/dayLength);
  scene.background.b = 0.8*Math.cos(time/dayLength);
  scene.fog.color = scene.background;
  general_light.intensity = Math.max(scene.background.b, 0.3);
  hour = Math.round(71.5+(Math.cos(time/dayLength/2+Math.PI/2))*-Math.sign(Math.sin(time/dayLength/2+Math.PI/2))*71.5);
  $("#clock").text(String(parseHour(hour)));
  for (const objId in lookaters){
  // scene.getObjectById(boxes[objId]).rotation.y += 0.01;
  // scene.getObjectById(boxes[objId]).lookAt(camera.position.x, 0.5, camera.position.z);
  // scene.getObjectById(boxes[objId]).rotateY(Math.PI/2+Math.PI);
  var curObj = scene.getObjectById(lookaters[objId]);
  stare(curObj);
  }
  // $("#console").html(String(camera.position.x)+"<br>"+String(camera.position.y)+"<br>"+String(camera.position.z)+"<br>");
  sun.lookAt(camera.position);
  if (cameraTouchMove == true){
    rotateCamera(movementX/-1000, movementY/-1000);
  }
  // applyAcceleration(camera_velocity, gravity);
  resistanceDeceleration(camera_velocity);
  if(camera.position.y>jump_lim&&debug != true){camera_acceleration.y = 0; jumped = true;}
  applyAcceleration(camera_velocity, camera_acceleration);

  applyVelocity(camera, camera_velocity, debug);
  playerHitbox.position.copy(camera.position);
  playerHitbox.translateY(-0.4);
  // playerHitbox.position.y = 0.9
  // console.log(playerHitbox.geometry);
  var originPoint = playerHitbox.position.clone();
  grounded = 0;
  if(!debug){
    for (var vertexIndex = 0; vertexIndex < playerHitbox.geometry.attributes.position.count; vertexIndex++)
    {
        var localVertex = new THREE.Vector3();
        var globalVertex = new THREE.Vector3();
        localVertex.fromBufferAttribute( playerHitbox.geometry.attributes.position, vertexIndex ); 
        globalVertex = localVertex.applyMatrix4( playerHitbox.matrix );
        var directionVector = globalVertex.sub( playerHitbox.position );
        var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
        var collisionResults = ray.intersectObjects( collidableMeshList );
        if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) {
          
          if(directionVector.y>0.4&&jumped){
            // console.log("dupa");
            camera.position.y -= 0.0005;
            jumped = true; jump_lim = camera.position.y-2;}
          if(directionVector.y<-0.35){
            applyAcceleration(camera_velocity, repulsion_vector); grounded++; jump_lim = camera.position.y+2; }

          if(directionVector.y>-0.2&&directionVector.y<0.3){
            var antiCollisionResults = ray.intersectObjects( antiCollidableMeshList );
            
            if ((antiCollisionResults.length > 0 && antiCollisionResults[0].distance < directionVector.length())){
              }else{
            jumped = true;
            camera.position. x += directionVector.negate().projectOnPlane(global_axis_y).setLength(acc_val/25).x;
            camera.position.z -= directionVector.negate().projectOnPlane(global_axis_y).setLength(acc_val/25).z;
            }
          }
        
      }
    }
    // $("#console").html(String(jump_lim)+"<br>"+String( grounded)+"<br>"+String(jumped));
    if (grounded>65)jumped = false;else jumped = true;	
  }
}

const repulsion_vector = new THREE.Vector3(0, 0.01,0);
const interactRange = 2;
function interact(){
        var rayDirection = new THREE.Vector3();
        camera.getWorldDirection(rayDirection);
        var ray = new THREE.Raycaster( camera.position, rayDirection.normalize() );
        var intersected = ray.intersectObjects( interactive );
        if ( intersected.length > 0 && intersected[0].distance < interactRange ){
          actions[intersected[0].object.id](intersected[0].object.id);
        }
        else{
          $("#textbox").hide();
        }
}
let touchscreen = false;
document.addEventListener("mousemove", updateDisplay, false);
document.addEventListener("dblclick", openFullscreen, false);
document.addEventListener("touchstart", openFullscreen, false);
document.addEventListener("touchstart", function(e){touchscreen=true; $("#interactTouchBox").show();$("#cameraTouchBox").show();$("#movementTouchBox").show();$("#jumpTouchBox").show(); }, false);
document.getElementById("cameraTouchBox").addEventListener("touchstart", handleStartCamera, false);
document.getElementById("jumpTouchBox").addEventListener("touchstart", handleStartJump, false);
document.getElementById("jumpTouchBox").addEventListener("touchend", handleEndJump, false);
document.getElementById("interactTouchBox").addEventListener("touchstart", handleStartInteract, false);
document.getElementById("interactTouchBox").addEventListener("touchend", handleEndInteract, false);
document.getElementById("cameraTouchBox").addEventListener("touchend", handleEndCamera, false);
document.getElementById("cameraTouchBox").addEventListener("touchmove", handleMoveCamera, false);
document.getElementById("movementTouchBox").addEventListener("touchstart", handleStartMovement, false);
document.getElementById("movementTouchBox").addEventListener("touchend", handleEndMovement, false);
document.getElementById("movementTouchBox").addEventListener("touchmove", handleMoveMovement, false);
document.getElementById("dayLength").addEventListener("change", function(){dayLength = document.getElementById("dayLength").value});
var keysPressed = {};

var acc_val = 0.2;
var jump_lim = 2.5;


document.addEventListener('keydown', handleKeydown);
function handleKeydown(event){
   keysPressed[event.key.toLowerCase()] = true;
   camera.getWorldDirection(camera_global_direction);
   if (keysPressed['arrowup']||keysPressed['w']) {
     camera_acceleration.z = -acc_val;
   } if (keysPressed['arrowright']||keysPressed['d']) {
    camera_acceleration.x = acc_val;
   }if (keysPressed['arrowleft']||keysPressed['a']) {
    camera_acceleration.x= -acc_val;
   }if (keysPressed['arrowdown']||keysPressed['s']) {
    camera_acceleration.z = acc_val;
   }if (keysPressed['`']) {
    $("#console").show();
   }if (keysPressed[' ']) {
    if(jumped == false||debug){ camera_acceleration.y = 7*acc_val; jumped = true;}
    if(debug)camera_acceleration.y = acc_val;
   }if (keysPressed['shift']&&debug) {
    camera_acceleration.y = -acc_val;
   }
   if (keysPressed['e']) {
      interact();
   }
   if (keysPressed['z']) {
      toggleDebug();
      //console.log(keysPressed);
   }
  //  event.preventDefault();
}
var debug = false;
function toggleDebug(){
  debug = !debug;
  if(debug)acc_val = 1;else acc_val = 0.2;
}
var releasedKey="";
document.addEventListener('keyup', (event) => {
  console.log(event.key);
  releasedKey = event.key.toLowerCase();
  if (releasedKey =='arrowup'||releasedKey == 'w') {
     camera_acceleration.z =  0;
     if (keysPressed['arrowdown']||keysPressed['s']) {
    camera_acceleration.z = acc_val;
   }
  
   } if (releasedKey =='arrowright'||releasedKey =='d') {
    camera_acceleration.x = 0;
    if (keysPressed['arrowleft']||keysPressed['a']) {
    camera_acceleration.x= -acc_val;
    }
   }if (releasedKey =='arrowleft'||releasedKey =='a') {
    camera_acceleration.x= 0;
    if (keysPressed['arrowright']||keysPressed['d']) {
    camera_acceleration.x = acc_val;
   }
   }if (releasedKey =='arrowdown'||releasedKey =='s') {
    camera_acceleration.z = 0;
    if (keysPressed['arrowup']||keysPressed['w']) {
     camera_acceleration.z = -acc_val;
    }
   }if (releasedKey ==' ') {
    camera_acceleration.y = 0;
    if (keysPressed['shift']&&debug) {
     camera_acceleration.y = -acc_val;
    }
   }if (releasedKey=='shift') {
    camera_acceleration.y = 0;
    if (keysPressed[' ']) {
     camera_acceleration.y = acc_val;
    }
   }
    
       delete keysPressed[event.key.toLowerCase()];
  //  event.preventDefault();
    //  camera_velocity.x = 0;
    //  camera_velocity.z = 0;

});

function applyVelocity(obj, vel, flight){
  var vst = 0.007;
  var orientation = new THREE.Vector3();
  obj.getWorldDirection(orientation);
  
  
  orientation.y = 0;
  var k = (orientation.x*100)/(orientation.z*100);

  var d = 1/Math.sqrt(k**2+1);
  if (d==NaN){
    d = 0;
  }
  // if(debug)console.log(d, k, orientation.x*1000, orientation.z);
  // obj.localToWorld(orientation);
  if (Math.abs(vel.x) < vst){
    vel.x = 0;
  }else{
    if(flight) obj.translateX(vel.x); else {
  obj.position.x -= vel.x*d*Math.sign(orientation.z);
  obj.position.z -= -vel.x*d*Math.abs(k)*Math.sign(orientation.x)}}
  if (Math.abs(vel.y) < vst){
    vel.y = 0;
  }else{ if (flight) obj.position.y +=vel.y;else{
  obj.position.y +=vel.y;}}

  if (Math.abs(vel.z) < vst){
    vel.z = 0;
  }else{
    if (flight){obj.translateZ(vel.z)}else{
    obj.position.z -= vel.z*d*Math.sign(orientation.z);
  obj.position.x -= vel.z*d*Math.abs(k)*Math.sign(orientation.x)}}
}

function applyAcceleration(vel, acc){
  vel.addScaledVector(acc, 0.1);
}

function resistanceDeceleration(vel){
  const rf = 50;
  // console.log(-rf*(Math.sign(vel.y)*(vel.y**2)-gravity.y));
  if(debug)var g=0;else var g = gravity.y;
  applyAcceleration(vel, new THREE.Vector3(-rf*Math.sign(vel.x)*(vel.x**2), -rf*(Math.sign(vel.y)*(vel.y**2)-g), -rf*Math.sign(vel.z)*(vel.z**2)));
}

function updateDisplay(e){
  var movementX = e.movementX || e.mozMovementX || 0;
  var movementY = e.movementY || e.mozMovementY ||  0;
  rotateCamera(movementX/-100, movementY/-100);
}
let touchLim = 40;
let movementX = 0;
let movementY = 0;
let cameraTouchMove = false;

function ongoingTouchIndexById(idToFind) {
  for (var i = 0; i < ongoingTouches.length; i++) {
    var id = ongoingTouches[i].identifier;

    if (id == idToFind) {
      return i;
    }
  }
  return -1;    // not found
}

function MongoingTouchIndexById(idToFind) {
  for (var i = 0; i < MongoingTouches.length; i++) {
    var id = MongoingTouches[i].identifier;

    if (id == idToFind) {
      return i;
    }
  }
  return -1;    // not found
}
function copyTouch(touch) {
  return { identifier: touch.identifier, pageX: touch.pageX, pageY: touch.pageY };
}
var ongoingTouches = [];
var MongoingTouches = [];

var initialTouchXcamera;
var initialTouchYcamera;
var initialTouchXmovement;
var initialTouchYmovement;
function handleStartCamera(evt) {
  evt.preventDefault();
  var touches = evt.changedTouches;
  cameraTouchMove = true;
  for (var i = 0; i < touches.length; i++) {
    ongoingTouches.push(copyTouch(touches[i]));
    initialTouchXcamera = touches[i].clientX;
    initialTouchYcamera= touches[i].clientY;   
  }
}
function handleStartJump(evt) {
  evt.preventDefault();
  if(jumped == false||debug){ camera_acceleration.y = 7*acc_val; jumped = true;}
  if(debug)camera_acceleration.y = acc_val;
  
}
function handleEndJump(evt) {
  evt.preventDefault();
  if(debug)camera_acceleration.y = 0;
  
}
function handleStartInteract(evt) {
  evt.preventDefault();
  interact();
  
}
function handleEndInteract(evt) {

}
function handleMoveCamera(evt) {
  // console.log("wykryto dotyk");
  // console.log(initialTouchXcamera,  initialTouchYcamera);
  evt.preventDefault();
  
  var touches = evt.changedTouches;

  for (var i = 0; i < touches.length; i++) {
        var idx = ongoingTouchIndexById(touches[i].identifier);

    if (idx >= 0) {
      let bounds = document.getElementById("cameraTouchBox").getBoundingClientRect();

    movementX = touches[i].clientX-initialTouchXcamera;
    movementY = touches[i].clientY-initialTouchYcamera;
    if (movementX>touchLim){ movementX = touchLim;}
    if (movementY>touchLim){ movementY = touchLim;}
    if (movementX<-touchLim){ movementX = -touchLim;}
    if (movementY<-touchLim){ movementY = -touchLim;}
      // console.log(movementX, movementY);
      
      ongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
      // console.log(".");
    } else {
      // console.log("can't figure out which touch to continue");
    }
  }
}
function handleEndCamera(evt) {
  evt.preventDefault();

  var touches = evt.changedTouches;
  rotateCamera(movementX/-1000, movementY/-1000);
  cameraTouchMove = false;
  for (var i = 0; i < touches.length; i++) {
    var idx = ongoingTouchIndexById(touches[i].identifier);
    if (idx >= 0) {
      ongoingTouches.splice(idx, 1);  // remove it; we're done
    } 
  }
}
function handleStartMovement(evt) {
  evt.preventDefault();
  var touches = evt.changedTouches;
  
  for (var i = 0; i < touches.length; i++) {
    MongoingTouches.push(copyTouch(touches[i]));
    initialTouchXmovement = touches[i].clientX;
    initialTouchYmovement= touches[i].clientY;   
  }
}
function handleMoveMovement(evt) {
  // console.log("wykryto dotyk");
  // console.log(initialTouchXcamera,  initialTouchYcamera);
  evt.preventDefault();
 
  var touches = evt.changedTouches;

  for (var i = 0; i < touches.length; i++) {
        var idx = MongoingTouchIndexById(touches[i].identifier);

    if (idx >= 0) {
      let bounds = document.getElementById("cameraTouchBox").getBoundingClientRect();

    camera_acceleration.x = 0.01*(touches[i].clientX-initialTouchXmovement)/4;
    camera_acceleration.z = 0.01*(touches[i].clientY-initialTouchYmovement)/4;
    if (camera_acceleration.x>acc_val){ camera_acceleration.x = acc_val;}
    if (camera_acceleration.z>acc_val){ camera_acceleration.z = acc_val;}
    if (camera_acceleration.x<-acc_val){ camera_acceleration.x = -acc_val;}
    if (camera_acceleration.z<-acc_val){ camera_acceleration.z = -acc_val;}
      // console.log(movementX, movementY);
      
      MongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
      // console.log(".");
    } 
  }
}
function handleEndMovement(evt) {
  evt.preventDefault();
  camera_acceleration.z = 0;
  camera_acceleration.x = 0;
  var touches = evt.changedTouches;
  camera;
 
  for (var i = 0; i < touches.length; i++) {
    var idx = MongoingTouchIndexById(touches[i].identifier);
    if (idx >= 0) {
      MongoingTouches.splice(idx, 1);  // remove it; we're done
    } 
  }
}


window.onload = init();
var global_axis_y = new THREE.Vector3(0,1,0);
var camera_global_direction = new THREE.Vector3();
var camera_velocity = new THREE.Vector3(0 ,0, 0);
var camera_acceleration = new THREE.Vector3(0,0,0);
var gravity = new THREE.Vector3(0,-0.01,0);

function rotateCamera(hor, vert){
  
  camera.getWorldDirection(camera_global_direction);
  camera.rotateOnWorldAxis(global_axis_y, hor);
  playerHitbox.rotation.y = camera.rotation.y;
  if((camera_global_direction.angleTo(global_axis_y)<0.2&&vert>0) || (camera_global_direction.angleTo(global_axis_y)>3&&vert<0)){
    // console.log("x rotation over");
  }else{
    camera.rotateX(vert);
  }
}


      </script>
      <style>
        canvas {
        position: absolute;
        width : 100vw;
        height : 100vh;
        top: 0px;
        left: 0px;
        padding : 0;
        border : none;
        background-color : black;
      }
      #cameraTouchBox{
        z-index: 100;
        position: absolute;
        right:5px;
        bottom: 5px;
        width: 27vw;
        height: 27vw;
        opacity: 33%;
        background-color: black;
        border-radius: 100vw;

        font-size: 10vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #movementTouchBox{
        z-index: 100;
        position: absolute;
        left:5px;
        bottom: 5px;
        width: 27vw;
        height: 27vw;
        opacity: 33%;
        background-color: black;
        border-radius: 100vw;

        font-size: 10vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      @font-face{
        font-family: "dogicabold";
        src: url("resources/dogicabold.ttf")
      }
      #clock{
        z-index: 100;
        position: absolute;
        font-size: 2.5vw;
        color: white;
        background-color: black;
        padding: 1vw;
        opacity: 75%;
        border-radius: 10vw;
        right: 0px;
        font-family: "dogicabold", monospace;
      }
      body{
        font-family:  monospace;
      }
      #console{
        z-index: 100;
        position: absolute;
        font-size: 2.5vw;
        color: white;
        background-color: black;
        padding: 1vw;
        opacity: 75%;
        border-radius: 10vw;
        left: 0px;
        
      }
      #jumpTouchBox{
        z-index: 100;
        position: absolute;
        right:5px;
        bottom: 29vw;
        z-index: 100;
        height: 10vw;
        opacity: 33%;
        background-color: black;
        font-size: 8vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #interactTouchBox{
        z-index: 100;
        position: absolute;
        left:5px;
        bottom: 29vw;
        z-index: 100;
        height: 10vw;
        opacity: 33%;
        background-color: black;
        font-size: 8vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #textbox{
        position: absolute;
        left: 2vw;
        width: 96vw;
        /* height: 30vh; */
        background-color: #002e5a;
        opacity: 95%;
        border-radius: 2vw;
        z-index: 200;
        bottom: 2vw;
        
        
      }
      #portrait-box{
        height: 29vh;
        width: 27vh;
        object-fit: cover;
        border-radius: 2vh;
      }
      #portrait{
        image-rendering: pixelated;
        position: relative;
        height: 29vh;
        width: 100%;
        object-fit: cover;
        object-position: 20% 10%; 
        
      }
      #speaker-name{
        position: relative;
        font-size: 5vh;
        color: white;
      }
      #text-area{
        position: relative;
        top: 0px;
        height: 15vh;
        font-size: 4vh;
        color: white;
        font-family: monospace;
        vertical-align: top;
      }
      
      </style>
    </head>
    <body>
      <canvas></canvas>
      <div id="clock">00:00</div>
      <div id="console">
        dayLength<input type="range" id="dayLength" value="100000" min="1000" max="100000"step="100"></input><br>



      </div>
      <div id="cameraTouchBox"> üëÅÔ∏è </div>
      <div id="movementTouchBox"> üïπÔ∏è </div>
      <div id="jumpTouchBox"> üÜô </div>
      <div id="interactTouchBox"> üëÜ </div>
      <div id="textbox">
        <table>
          <tr>
        <td rowspan="2" style="border:3px solid white;background:#aaa;opacity: 100%; border-radius: 2vh;"><div id="portrait-box"><img id="portrait"src="resources/npc_2_front.png"></img></div></td>
        <td><div id="speaker-name">Studenci U≈ö</div></td>
        </tr>
        <tr>

          <td>
            <div id="text-area">Hej! Daj paluszka...
            </div>
          </td> 
          
        </tr>
      </table>
      </div>
    </body>


</html>