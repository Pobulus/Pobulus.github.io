<html>
    <head>
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
      <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/pin/three@v0.128.0-SK0zhlI7UZNd0gIQdpJa/mode=imports/optimized/three.js';
        let camera, scene, renderer;
        let step;
        let geometry, material, mesh, ground, groundgeometry, ground_material;
        const loader = new THREE.TextureLoader();
        const textureWater = loader.load("https://pobulus.github.io/WebGl/resources/water.png");
        const texture_vending_machine = [
        new THREE.MeshBasicMaterial({map: loader.load("https://pobulus.github.io/WebGl/resources/vending_machine_front.png")}),  
        new THREE.MeshBasicMaterial({map: loader.load("https://pobulus.github.io/WebGl/resources/vending_machine_back.png")}),  
        new THREE.MeshBasicMaterial({map: loader.load("https://pobulus.github.io/WebGl/resources/vending_machine_top.png")}),  
        new THREE.MeshBasicMaterial({map: loader.load("https://pobulus.github.io/WebGl/resources/vending_machine_bottom.png")}),  
        new THREE.MeshBasicMaterial({map: loader.load("https://pobulus.github.io/WebGl/resources/vending_machine_left.png")}),  
        new THREE.MeshBasicMaterial({map: loader.load("https://pobulus.github.io/WebGl/resources/vending_machine_right.png")}),  
      ];
          var x = 0.0;
        function init() {
          $("#cameraTouchBox").hide();
          $("#movementTouchBox").hide();
          $("#jumpTouchBox").hide();
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 100 );
        camera.position.z = 0;
        camera.rotation.x = 0;
        camera.rotation.y = 0;
        scene = new THREE.Scene();
        geometry = new THREE.BoxGeometry( 0.1, 0.2, 0.2);
        
        textureWater.wrapS = THREE.RepeatWrapping;
        textureWater.wrapT = THREE.RepeatWrapping;
        ground_material = new THREE.MeshBasicMaterial({opacity: 0.5, map: textureWater,side: THREE.DoubleSide});
        groundgeometry = new THREE.PlaneGeometry(10, 10);
        
        ground = new THREE.Mesh(groundgeometry, ground_material);
        ground.position.y=-0.1;
        ground.rotation.x=-Math.PI/2;
        makeRandomBoxes(20);
        scene.add( ground );
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setAnimationLoop( animation );
        document.body.appendChild( renderer.domElement );
      }
      var elem = document.documentElement;
        let fullscr = false;
        function openFullscreen() {
          fullscr = true;
          
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) { /* Safari */
            elem.webkitRequestFullscreen();
        } else if (elem.msRequestFullscreen) { /* IE11 */
            elem.msRequestFullscreen();
        }
        sleep(1000);
        if (
  document.fullscreenElement || /* Standard syntax */
  document.webkitFullscreenElement || /* Safari and Opera syntax */
  document.msFullscreenElement /* IE11 syntax */
) {
      renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( window.innerWidth, window.innerHeight );
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.replaceChild( renderer.domElement, document.getElementsByTagName("canvas")[0] );
      // console.log("fullscreen");
      document.removeEventListener("touchstart", openFullscreen);
}
        }
function makeRandomBoxes(ammount){
  for (var dubstep = 0; dubstep<ammount; dubstep++){
    for (step = 0; step<ammount; step++){
      geometry = new THREE.BoxGeometry( Math.random(),  Math.random(),  Math.random());
      material = new THREE.MeshBasicMaterial();
      material.map = texture_vending_machine;
      material.needsUpdate = true;
      mesh = new THREE.Mesh( geometry, material );
      scene.add( mesh );
      mesh.position.y = 0.5;
      mesh.position.x = step-ammount/2;
      mesh.position.z = dubstep-ammount/2;
    }
}
}
function sleep(milliseconds) {
  const date = Date.now();
  let currentDate = null;
  do {
    currentDate = Date.now();
  } while (currentDate - date < milliseconds);
}
        
      
      function closeFullscreen(){
        fullscr = false;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen();
        }
}

function animation( time ) {
	renderer.render( scene, camera );
  if (cameraTouchMove == true){
    rotateCamera(movementX/-1000, movementY/-1000);
  }
  resistanceDeceleration(camera_velocity);
  applyAcceleration(camera_velocity, camera_acceleration);

  applyVelocity(camera, camera_velocity);
  applyAcceleration(camera_velocity, gravity);
  if(camera.position.y<0.5) camera.position.y = 0.5;
  if(debug){console.log(camera_acceleration, camera_velocity);console.log(keysPressed);}
  // camera_acceleration = new THREE.Vector3(0,0,0);
  
}
let touchscreen = false;
document.addEventListener("mousemove", updateDisplay, false);

document.addEventListener("touchstart", openFullscreen, false);
document.addEventListener("touchstart", function(e){touchscreen=true; $("#cameraTouchBox").show();$("#movementTouchBox").show();$("#jumpTouchBox").show(); }, false);
document.getElementById("cameraTouchBox").addEventListener("touchstart", handleStartCamera, false);
document.getElementById("cameraTouchBox").addEventListener("touchend", handleEndCamera, false);
document.getElementById("cameraTouchBox").addEventListener("touchmove", handleMoveCamera, false);
document.getElementById("movementTouchBox").addEventListener("touchstart", handleStartMovement, false);
document.getElementById("movementTouchBox").addEventListener("touchend", handleEndMovement, false);
document.getElementById("movementTouchBox").addEventListener("touchmove", handleMoveMovement, false);
var keysPressed = {};
const acc_val = 0.2;
const jump_lim = 1;
document.addEventListener('keydown', handleKeydown);
function handleKeydown(event){
   keysPressed[event.key.toLowerCase()] = true;
   camera.getWorldDirection(camera_global_direction);
   if (keysPressed['arrowup']||keysPressed['w']) {
     camera_acceleration.z = -acc_val;
   } if (keysPressed['arrowright']||keysPressed['d']) {
    camera_acceleration.x = acc_val;
   }if (keysPressed['arrowleft']||keysPressed['a']) {
    camera_acceleration.x= -acc_val;
   }if (keysPressed['arrowdown']||keysPressed['s']) {
    camera_acceleration.z = acc_val;
   }if (keysPressed[' ']) {
    if(camera.position.y < jump_lim){ camera_acceleration.y = 5*acc_val;delete keysPressed[event.key.toLowerCase()]}else{camera_acceleration.y = 0;}
   }if (keysPressed['shift']) {
    camera_acceleration.y = -acc_val;
   }
  
   if (keysPressed['z']) {
      toggleDebug();
      //console.log(keysPressed);
   }
  //  event.preventDefault();
}
var debug = false;
function toggleDebug(){
  debug = !debug;
}
var releasedKey="";
document.addEventListener('keyup', (event) => {
  console.log(event.key);
  releasedKey = event.key.toLowerCase();
  if (releasedKey =='arrowup'||releasedKey == 'w') {
     camera_acceleration.z =  0;
     if (keysPressed['arrowdown']||keysPressed['s']) {
    camera_acceleration.z = acc_val;
   }
  
   } if (releasedKey =='arrowright'||releasedKey =='d') {
    camera_acceleration.x = 0;
    if (keysPressed['arrowleft']||keysPressed['a']) {
    camera_acceleration.x= -acc_val;
    }
   }if (releasedKey =='arrowleft'||releasedKey =='a') {
    camera_acceleration.x= 0;
    if (keysPressed['arrowright']||keysPressed['d']) {
    camera_acceleration.x = acc_val;
   }
   }if (releasedKey =='arrowdown'||releasedKey =='s') {
    camera_acceleration.z = 0;
    if (keysPressed['arrowup']||keysPressed['w']) {
     camera_acceleration.z = -acc_val;
    }
   }if (releasedKey ==' ') {
    camera_acceleration.y = 0;
    if (keysPressed['shift']) {
     camera_acceleration.y = -acc_val;
    }
   }if (releasedKey=='shift') {
    camera_acceleration.y = 0;
    console.log("got here!");
    if (keysPressed[' ']) {
     camera_acceleration.y = acc_val;
    }
   }
    
       delete keysPressed[event.key.toLowerCase()];
  //  event.preventDefault();
    //  camera_velocity.x = 0;
    //  camera_velocity.z = 0;

});

function applyVelocity(obj, vel){
  var vst = 0.007;
  var orientation = new THREE.Vector3();
  obj.getWorldDirection(orientation);
  
  
  orientation.y = 0;
  var k = (orientation.x*100)/(orientation.z*100);

  var d = 1/Math.sqrt(k**2+1);
  if (d==NaN){
    d = 0;
  }
  // if(debug)console.log(d, k, orientation.x*1000, orientation.z);
  // obj.localToWorld(orientation);
  if (Math.abs(vel.x) < vst){
    vel.x = 0;
  }else{
    obj.position.x -= vel.x*d*Math.sign(orientation.z);
  obj.position.z -= -vel.x*d*Math.abs(k)*Math.sign(orientation.x)}
  if (Math.abs(vel.y) < vst){
    vel.y = 0;
  }else{
  obj.position.y +=vel.y;}

  if (Math.abs(vel.z) < vst){
    vel.z = 0;
  }else{
    obj.position.z -= vel.z*d*Math.sign(orientation.z);
  obj.position.x -= vel.z*d*Math.abs(k)*Math.sign(orientation.x)}
}
function applyAcceleration(vel, acc){
  vel.addScaledVector(acc, 0.1);
}
function resistanceDeceleration(vel){
  const rf = 50;
  applyAcceleration(vel, new THREE.Vector3(-rf*Math.sign(vel.x)*(vel.x**2), -rf*Math.sign(vel.y)*(vel.y**2), -rf*Math.sign(vel.z)*(vel.z**2)));
}
function updateDisplay(e){
  var movementX = e.movementX || e.mozMovementX || 0;
  var movementY = e.movementY || e.mozMovementY ||  0;
  rotateCamera(movementX/-100, movementY/-100);
}
let touchLim = 40;
let movementX = 0;
let movementY = 0;
let cameraTouchMove = false;

function ongoingTouchIndexById(idToFind) {
  for (var i = 0; i < ongoingTouches.length; i++) {
    var id = ongoingTouches[i].identifier;

    if (id == idToFind) {
      return i;
    }
  }
  return -1;    // not found
}

function MongoingTouchIndexById(idToFind) {
  for (var i = 0; i < MongoingTouches.length; i++) {
    var id = MongoingTouches[i].identifier;

    if (id == idToFind) {
      return i;
    }
  }
  return -1;    // not found
}
function copyTouch(touch) {
  return { identifier: touch.identifier, pageX: touch.pageX, pageY: touch.pageY };
}
var ongoingTouches = [];
var MongoingTouches = [];

var initialTouchXcamera;
var initialTouchYcamera;
var initialTouchXmovement;
var initialTouchYmovement;
function handleStartCamera(evt) {
  evt.preventDefault();
  var touches = evt.changedTouches;
  cameraTouchMove = true;
  for (var i = 0; i < touches.length; i++) {
    ongoingTouches.push(copyTouch(touches[i]));
    initialTouchXcamera = touches[i].clientX;
    initialTouchYcamera= touches[i].clientY;   
  }
}
function handleMoveCamera(evt) {
  // console.log("wykryto dotyk");
  // console.log(initialTouchXcamera,  initialTouchYcamera);
  evt.preventDefault();
 
  var touches = evt.changedTouches;

  for (var i = 0; i < touches.length; i++) {
        var idx = ongoingTouchIndexById(touches[i].identifier);

    if (idx >= 0) {
      let bounds = document.getElementById("cameraTouchBox").getBoundingClientRect();

    movementX = touches[i].clientX-initialTouchXcamera;
    movementY = touches[i].clientY-initialTouchYcamera;
    if (movementX>touchLim){ movementX = touchLim;}
    if (movementY>touchLim){ movementY = touchLim;}
    if (movementX<-touchLim){ movementX = -touchLim;}
    if (movementY<-touchLim){ movementY = -touchLim;}
      // console.log(movementX, movementY);
      
      ongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
      // console.log(".");
    } else {
      // console.log("can't figure out which touch to continue");
    }
  }
}
function handleEndCamera(evt) {
  evt.preventDefault();

  var touches = evt.changedTouches;
  rotateCamera(movementX/-1000, movementY/-1000);
  cameraTouchMove = false;
  for (var i = 0; i < touches.length; i++) {
    var idx = ongoingTouchIndexById(touches[i].identifier);
    if (idx >= 0) {
      ongoingTouches.splice(idx, 1);  // remove it; we're done
    } 
  }
}
function handleStartMovement(evt) {
  evt.preventDefault();
  var touches = evt.changedTouches;
  
  for (var i = 0; i < touches.length; i++) {
    MongoingTouches.push(copyTouch(touches[i]));
    initialTouchXmovement = touches[i].clientX;
    initialTouchYmovement= touches[i].clientY;   
  }
}
function handleMoveMovement(evt) {
  // console.log("wykryto dotyk");
  // console.log(initialTouchXcamera,  initialTouchYcamera);
  evt.preventDefault();
 
  var touches = evt.changedTouches;

  for (var i = 0; i < touches.length; i++) {
        var idx = MongoingTouchIndexById(touches[i].identifier);

    if (idx >= 0) {
      let bounds = document.getElementById("cameraTouchBox").getBoundingClientRect();

    camera_acceleration.x = 0.01*(touches[i].clientX-initialTouchXmovement)/4;
    camera_acceleration.z = 0.01*(touches[i].clientY-initialTouchYmovement)/4;
    if (camera_acceleration.x>acc_val){ camera_acceleration.x = acc_val;}
    if (camera_acceleration.z>acc_val){ camera_acceleration.z = acc_val;}
    if (camera_acceleration.x<-acc_val){ camera_acceleration.x = -acc_val;}
    if (camera_acceleration.z<-acc_val){ camera_acceleration.z = -acc_val;}
      // console.log(movementX, movementY);
      
      MongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
      // console.log(".");
    } 
  }
}
function handleEndMovement(evt) {
  evt.preventDefault();
  camera_acceleration.z = 0;
  camera_acceleration.x = 0;
  var touches = evt.changedTouches;
  camera;
 
  for (var i = 0; i < touches.length; i++) {
    var idx = MongoingTouchIndexById(touches[i].identifier);
    if (idx >= 0) {
      MongoingTouches.splice(idx, 1);  // remove it; we're done
    } 
  }
}

ondblclick = function(e){openFullscreen();}
window.onload = init();
var global_axis_y = new THREE.Vector3(0,1,0);
var camera_global_direction = new THREE.Vector3();
var camera_velocity = new THREE.Vector3(0 ,0, 0);
var camera_acceleration = new THREE.Vector3(0,0,0);
var gravity = new THREE.Vector3(0,-1.5,0);

function rotateCamera(hor, vert){
  camera.getWorldDirection(camera_global_direction);
  camera.rotateOnWorldAxis(global_axis_y, hor);
  if((camera_global_direction.angleTo(global_axis_y)<0.2&&vert>0) || (camera_global_direction.angleTo(global_axis_y)>3&&vert<0)){
    // console.log("x rotation over");
  }else{
    camera.rotateX(vert);
  }
}

var canvas = document.querySelector('canvas');
        canvas.requestPointerLock = canvas.requestPointerLock ||canvas.mozRequestPointerLock;
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;

        canvas.onclick = function() {
          if(touchscreen==false){
          canvas.requestPointerLock();
        }
      }
      </script>
      <style>
        canvas {
        position: absolute;
        width : 100vw;
        height : 100vh;
        top: 0px;
        left: 0px;
        padding : 0;
        border : none;
        background-color : black;
      }
      #cameraTouchBox{
        z-index: 100;
        position: absolute;
        right:5px;
        bottom: 5px;
        width: 27vw;
        height: 27vw;
        opacity: 33%;
        background-color: black;
        border-radius: 100vw;

        font-size: 10vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #movementTouchBox{
        z-index: 100;
        position: absolute;
        left:5px;
        bottom: 5px;
        width: 27vw;
        height: 27vw;
        opacity: 33%;
        background-color: black;
        border-radius: 100vw;

        font-size: 10vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }      
      
      #jumpTouchBox{
        z-index: 100;
        position: absolute;
        left:28vw;
        bottom: 5px;
        width: 10vw;
        height: 10vw;
        opacity: 33%;
        background-color: black;
        border-radius: 100vw;

        font-size: 10vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }    
      </style>
    </head>
    <body>
        
          
      <div id="cameraTouchBox"> 👁️ </div>
      <div id="movementTouchBox"> 🕹️ </div>
      <div id="jumpTouchBox"> 🆙 </div>
    </body>


</html>