<html>
    <head>
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
      <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/pin/three@v0.128.0-SK0zhlI7UZNd0gIQdpJa/mode=imports/optimized/three.js';
        let camera, scene, renderer;
        let geometry, material, mesh, ground, groundgeometry, ground_material;
        var x = 0.0;
        function init() {
          $("#cameraTouchBox").hide();
          $("#movementTouchBox").hide();
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
        camera.position.z = 0;
        camera.rotation.x = 0;
        camera.rotation.y = 0;
        scene = new THREE.Scene();
        geometry = new THREE.BoxGeometry( 0.1, 0.2, 0.2);
        material = new THREE.MeshNormalMaterial();
        ground_material = new THREE.MeshBasicMaterial({color: 0x0022dd,side: THREE.DoubleSide});
        groundgeometry = new THREE.PlaneGeometry(1, 1);
        mesh = new THREE.Mesh( geometry, material );
        ground = new THREE.Mesh(groundgeometry, ground_material);
        ground.position.y=-0.1;
        ground.rotation.x=-Math.PI/2;
        scene.add( mesh );
         mesh.position.z = -0.5
        scene.add( ground );
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setAnimationLoop( animation );
        document.body.appendChild( renderer.domElement );
      }
      var elem = document.documentElement;
        let fullscr = false;
        function openFullscreen() {
          fullscr = true;
          
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) { /* Safari */
            elem.webkitRequestFullscreen();
        } else if (elem.msRequestFullscreen) { /* IE11 */
            elem.msRequestFullscreen();
        }
        if (
  document.fullscreenElement || /* Standard syntax */
  document.webkitFullscreenElement || /* Safari and Opera syntax */
  document.msFullscreenElement /* IE11 syntax */
) {
  renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( window.innerWidth, window.innerHeight );
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.replaceChild( renderer.domElement, document.getElementsByTagName("canvas")[0] );
      // console.log("fullscreen");
      document.removeEventListener("touchstart", openFullscreen);
}
        
      }
      function closeFullscreen(){
        fullscr = false;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen();
        }
}

function animation( time ) {
	renderer.render( scene, camera );
  if (cameraTouchMove == true){
    rotateCamera(movementX/-1000, movementY/-1000);
  }
  applyAcceleration(camera_velocity, camera_acceleration);
  resistanceDeceleration(camera_velocity);
  applyVelocity(camera, camera_velocity);
  camera_acceleration = new THREE.Vector3(0,0,0);
  
}
let touchscreen = false;
document.addEventListener("mousemove", updateDisplay, false);
document.getElementById("cameraTouchBox").addEventListener("touchmove", updateDisplayTouch, false);
document.addEventListener("touchstart", function(e){touchscreen=true; $("#cameraTouchBox").show();$("#movementTouchBox").show(); }, false);
document.addEventListener("touchstart", openFullscreen, false);
document.getElementById("cameraTouchBox").addEventListener("touchstart", handleStart, false);
document.getElementById("cameraTouchBox").addEventListener("touchend", handleEnd, false);
var keysPressed = {};
const acc_val = 0.03;
document.addEventListener('keypress', (event) => {
   keysPressed[event.key] = true;
   camera.getWorldDirection(camera_global_direction);
   if (keysPressed['ArrowUp']||keysPressed['w']) {
     camera_acceleration.z = -acc_val;
   } if (keysPressed['ArrowRight']||keysPressed['d']) {
    camera_acceleration.x = acc_val;
   }if (keysPressed['ArrowLeft']||keysPressed['a']) {
    camera_acceleration.x= -acc_val;
   }if (keysPressed['ArrowDown']||keysPressed['s']) {
    camera_acceleration.z = acc_val;
   }
   console.log(camera_acceleration, camera_velocity);
   if (keysPressed['z']) {
      
       console.log(camera_global_direction);
   }

});
document.addEventListener('keyup', (event) => {
  // if (keysPressed['ArrowUp']||keysPressed['w']) {
  //    camera_acceleration.z =  0;
  //  } if (keysPressed['ArrowRight']||keysPressed['d']) {
  //   camera_acceleration.x = 0;
  //  }if (keysPressed['ArrowLeft']||keysPressed['a']) {
  //   camera_acceleration.x= 0;
  //  }if (keysPressed['ArrowDown']||keysPressed['s']) {
  //   camera_acceleration.z = 0;
  //  }
    
   delete keysPressed[event.key];
   console.log(keysPressed);

    //  camera_velocity.x = 0;
    //  camera_velocity.z = 0;

});

function applyVelocity(obj, vel){
  if (Math.abs(vel.x) < 0.0001){
    vel.x = 0;
  }else{
  obj.translateX(vel.x);}
  if (Math.abs(vel.y) < 0.001){
    vel.y = 0;
  }else{
  obj.translateY(vel.y);}
  if (Math.abs(vel.z) < 0.001){
    vel.z = 0;
  }else{
  obj.translateZ(vel.z);}

  
}
function applyAcceleration(vel, acc){
  vel.add(acc);
}
function resistanceDeceleration(vel){
  const rf = 20;
  applyAcceleration(vel, new THREE.Vector3(-rf*Math.sign(vel.x)*(vel.x**2), -rf*Math.sign(vel.y)*(vel.y**2), -rf*Math.sign(vel.z)*(vel.z**2)));
}
function updateDisplay(e){
  var movementX = e.movementX || e.mozMovementX || 0;
  var movementY = e.movementY || e.mozMovementY ||  0;
  rotateCamera(movementX/-100, movementY/-100);
}
let touchLim = 40;
let movementX = 0;
let movementY = 0;
let cameraTouchMove = false;
function updateDisplayTouch(evt) {
  // console.log("wykryto dotyk");
  // console.log(initialTouchX,  initialTouchY);
  evt.preventDefault();
 
  var touches = evt.changedTouches;

  for (var i = 0; i < touches.length; i++) {
        var idx = ongoingTouchIndexById(touches[i].identifier);

    if (idx >= 0) {
      let bounds = document.getElementById("cameraTouchBox").getBoundingClientRect();

    movementX = touches[i].clientX-initialTouchX;
    movementY = touches[i].clientY-initialTouchY;
    if (movementX>touchLim){ movementX = touchLim;}
    if (movementY>touchLim){ movementY = touchLim;}
    if (movementX<-touchLim){ movementX = -touchLim;}
    if (movementY<-touchLim){ movementY = -touchLim;}
      // console.log(movementX, movementY);
      
      ongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
      // console.log(".");
    } else {
      // console.log("can't figure out which touch to continue");
    }
  }
}
function ongoingTouchIndexById(idToFind) {
  for (var i = 0; i < ongoingTouches.length; i++) {
    var id = ongoingTouches[i].identifier;

    if (id == idToFind) {
      return i;
    }
  }
  return -1;    // not found
}
function copyTouch(touch) {
  return { identifier: touch.identifier, pageX: touch.pageX, pageY: touch.pageY };
}
var ongoingTouches = [];
var initialTouchX;
var initialTouchY;
function handleStart(evt) {
  evt.preventDefault();
  // console.log("touchstart.");
  var touches = evt.changedTouches;
  cameraTouchMove = true;
  for (var i = 0; i < touches.length; i++) {
    // console.log("touchstart:" + i + "...");
    ongoingTouches.push(copyTouch(touches[i]));
    initialTouchX = touches[i].clientX;
    initialTouchY= touches[i].clientY;
    
    // console.log("touchstart:" + i + ".");
    
  }
}
function handleEnd(evt) {
  evt.preventDefault();
  // console.log("touchend");
  var touches = evt.changedTouches;
  rotateCamera(movementX/-1000, movementY/-1000);
  cameraTouchMove = false;

  for (var i = 0; i < touches.length; i++) {
    var idx = ongoingTouchIndexById(touches[i].identifier);

    if (idx >= 0) {
      
      ongoingTouches.splice(idx, 1);  // remove it; we're done
    } else {
      // console.log("can't figure out which touch to end");
    }
  }
}
// onclick = function(e){openFullscreen();}
window.onload = init();
var global_axis_y = new THREE.Vector3(0,1,0);
var camera_global_direction = new THREE.Vector3();
var camera_velocity = new THREE.Vector3(0 ,0, 0);
var camera_acceleration = new THREE.Vector3(0,0,0);

function rotateCamera(hor, vert){
  camera.getWorldDirection(camera_global_direction);
  camera.rotateOnWorldAxis(global_axis_y, hor);
  if((camera_global_direction.angleTo(global_axis_y)<0.2&&vert>0) || (camera_global_direction.angleTo(global_axis_y)>3&&vert<0)){
    // console.log("x rotation over");
  }else{
    camera.rotateX(vert);
  }
}

var canvas = document.querySelector('canvas');
        canvas.requestPointerLock = canvas.requestPointerLock ||canvas.mozRequestPointerLock;
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;

        canvas.onclick = function() {
          if(touchscreen==false){
          canvas.requestPointerLock();
        }
      }
      </script>
      <style>
        canvas {
        position: absolute;
        width : 100vw;
        height : 100vh;
        top: 0px;
        left: 0px;
        padding : 0;
        border : none;
        background-color : black;
      }
      #cameraTouchBox{
        z-index: 100;
        position: absolute;
        right:5px;
        bottom: 5px;
        width: 27vw;
        height: 27vw;
        opacity: 33%;
        background-color: black;
        border-radius: 100vw;

        font-size: 10vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #movementTouchBox{
        z-index: 100;
        position: absolute;
        left:5px;
        bottom: 5px;
        width: 27vw;
        height: 27vw;
        opacity: 33%;
        background-color: black;
        border-radius: 100vw;

        font-size: 10vw;
        display: flex;
        align-items: center;
        justify-content: center;
      }      
      

      </style>
    </head>
    <body>
        
          
      <div id="cameraTouchBox"> 👁️ </div>
      <div id="movementTouchBox"> 🕹️ </div>
    </body>


</html>